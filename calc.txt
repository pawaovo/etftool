function calculateEtfData(jsonData, latestNetValue) {
    try {
        // 检查JSON数据是否有效
        if (!jsonData || typeof jsonData !== 'object') {
            throw new Error('无效的ETF JSON数据');
        }
        
        // 适配实际的JSON结构
        // 从"网格交易示例表"字段提取ETF代码和名称
        let etfName = '未知ETF';
        let etfCode = '';
        if (jsonData["网格交易示例表"]) {
            const match = jsonData["网格交易示例表"].match(/(\d{6})\(([^)]+)\)/);
            if (match) {
                etfCode = match[1];
                etfName = match[2];
            } else {
                etfCode = extractEtfCodeFromFilename(jsonData.sourceFile || '');
                etfName = jsonData["网格交易示例表"];
            }
        } else {
            etfCode = extractEtfCodeFromFilename(jsonData.sourceFile || '');
        }
        
        // 提取ETF基本信息
        const category = etfName || '其他';
        const isRunning = jsonData["网格交易数据"] && jsonData["网格交易数据"].length > 0;
        
        // 计算步长
        let stepSize = '未知';
        if (jsonData["网格交易数据"] && jsonData["网格交易数据"].length >= 2) {
            try {
                const level1 = jsonData["网格交易数据"][0]["档位"];
                const level2 = jsonData["网格交易数据"][1]["档位"];
                if (level1 && level2) {
                    const smallStep = Math.abs((level1 - level2) * 100);
                    const mediumStep = smallStep * 3;
                    const largeStep = smallStep * 6;
                    stepSize = `${smallStep}/${mediumStep}/${largeStep}`;
                }
            } catch (error) {
                console.error('计算步长失败:', error);
            }
        }
        
        // 提取网格配置 - 转换为代码期望的格式
        const gridLevels = [];
        if (jsonData["网格交易数据"] && Array.isArray(jsonData["网格交易数据"])) {
            jsonData["网格交易数据"].forEach(grid => {
                try {
                    // 计算平均买入价
                    let buyPrice = 0;
                    if (Array.isArray(grid["买入价"]) && grid["买入价"].length > 0) {
                        const validPrices = grid["买入价"].map(p => parseFloat(p)).filter(p => !isNaN(p));
                        if (validPrices.length > 0) {
                            buyPrice = validPrices.reduce((sum, price) => sum + price, 0) / validPrices.length;
                        }
                    }
                    
                    // 添加到网格档位列表
                    gridLevels.push({
                        level: grid["档位"],
                        price: buyPrice,
                        type: grid["网格种类"],
                    });
                } catch (error) {
                    console.error('处理网格档位数据失败:', error);
                }
            });
        }
        
        // 提取执行记录 - 转换为代码期望的格式
        const executions = [];
        if (jsonData["交易记录"] && Array.isArray(jsonData["交易记录"])) {
            jsonData["交易记录"].forEach(record => {
                try {
                    // 确定交易类型
                    const amount = parseFloat(record["交易金额"]);
                    const type = amount < 0 ? 'SELL' : 'BUY';
                    
                    // 添加到执行记录列表
                    executions.push({
                        date: record["日期"],
                        type: type,
                        price: parseFloat(record["实际交易价格"]),
                        shares: Math.abs(parseFloat(record["交易股数"])),
                        amount: Math.abs(amount),
                        profit: type === 'SELL' ? parseFloat(record["收益"] || 0) : 0,
                        profitRate: type === 'SELL' ? record["收益率"] : '0.00%'
                    });
                } catch (error) {
                    console.error('处理交易记录数据失败:', error);
                }
            });
        }
        
        // 计算执行统计信息
        const executionCount = executions.filter(exec => exec.type === 'SELL').length;
        
        // 计算累计收益率
        let cumulativeYieldRate = '0.00%';
        try {
            // 计算总收益
            const totalProfit = executions.reduce((sum, exec) => {
                if (exec.type === 'SELL' && exec.profit) {
                    return sum + exec.profit;
                }
                return sum;
            }, 0);
            
            // 计算总买入金额
            const totalBuyAmount = executions.reduce((sum, exec) => {
                if (exec.type === 'BUY') {
                    return sum + exec.amount;
                }
                return sum;
            }, 0);
            
            // 计算累计收益率
            if (totalBuyAmount > 0) {
                const yieldRate = (totalProfit / totalBuyAmount) * 100;
                cumulativeYieldRate = yieldRate.toFixed(2) + '%';
            }
        } catch (error) {
            console.error('计算累计收益率失败:', error);
        }
        
        // 计算当前档位买入价
        let currentLevelBuyPrice = '0.0000';
        let currentLevel = 0.00;
        try {
            if (gridLevels.length > 0 && latestNetValue > 0) {
                // 按照价格升序排序网格档位
                const sortedLevels = [...gridLevels].sort((a, b) => 
                    parseFloat(a.price) - parseFloat(b.price)
                );
                
                // 根据最新净值找到当前应该买入的档位
                let matchedLevel = null;
                
                // 如果最新净值低于最低档位价格，使用最低档位
                if (latestNetValue <= parseFloat(sortedLevels[0].price)) {
                    matchedLevel = sortedLevels[0];
                } 
                // 如果最新净值高于最高档位价格，使用最高档位
                else if (latestNetValue >= parseFloat(sortedLevels[sortedLevels.length - 1].price)) {
                    matchedLevel = sortedLevels[sortedLevels.length - 1];
                } 
                // 否则找到最接近但低于最新净值的档位
                else {
                    for (let i = 0; i < sortedLevels.length - 1; i++) {
                        const currentPrice = parseFloat(sortedLevels[i].price);
                        const nextPrice = parseFloat(sortedLevels[i + 1].price);
                        
                        if (latestNetValue >= currentPrice && latestNetValue < nextPrice) {
                            matchedLevel = sortedLevels[i];
                            break;
                        }
                    }
                }
                
                if (matchedLevel) {
                    currentLevelBuyPrice = parseFloat(matchedLevel.price).toFixed(4);
                    currentLevel = matchedLevel.level;
                }
            }
        } catch (error) {
            console.error('计算当前档位买入价失败:', error);
        }
        
        // 计算净值变化率
        let netValueChangeRate = '0.00%';
        let headerColor = 'gray';
        try {
            const buyPrice = parseFloat(currentLevelBuyPrice);
            if (buyPrice > 0 && latestNetValue > 0) {
                const changeRate = (latestNetValue - buyPrice) / buyPrice * 100;
                netValueChangeRate = changeRate.toFixed(2) + '%';
                
                // 确定颜色：红色表示降低（适合买入），绿色表示上涨（适合卖出）
                headerColor = changeRate < 0 ? 'red' : 'green';
            }
        } catch (error) {
            console.error('计算净值变化率失败:', error);
        }
        
        // 返回格式化的ETF数据对象
        return {
            etfName,
            etfCode,
            category,
            isRunning,
            executionCount,
            cumulativeYieldRate,
            currentLevel,
            currentLevelBuyPrice,
            stepSize,
            latestNetValue: latestNetValue || 0,
            netValueChangeRate,
            headerColor,
            sourceFile: jsonData.sourceFile || '',
            gridLevels: gridLevels || [],
            executions: executions || []
        };
    } catch (error) {
        console.error('计算ETF数据失败:', error);
        throw error;
    }
}

